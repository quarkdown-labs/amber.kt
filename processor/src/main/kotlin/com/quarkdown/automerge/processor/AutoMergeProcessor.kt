package com.quarkdown.automerge.processor

import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.Modifier
import com.google.devtools.ksp.symbol.Nullability
import com.google.devtools.ksp.validate
import java.io.OutputStreamWriter

class AutoMergeProcessor(
    environment: SymbolProcessorEnvironment,
) : SymbolProcessor {
    private val logger: KSPLogger = environment.logger
    private val codeGenerator: CodeGenerator = environment.codeGenerator

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation("com.quarkdown.automerge.annotations.AutoMerge")
        val unableToProcess = mutableListOf<KSAnnotated>()
        symbols.forEach { symbol ->
            if (!symbol.validate()) {
                unableToProcess.add(symbol)
                return@forEach
            }
            val classDecl = symbol as? KSClassDeclaration
            if (classDecl == null) {
                logger.warn("@AutoMerge is applicable to classes only")
                return@forEach
            }
            if (classDecl.classKind != ClassKind.CLASS || !classDecl.modifiers.contains(Modifier.DATA)) {
                logger.error("@AutoMerge can only be used on data classes", classDecl)
                return@forEach
            }
            generateMergeExtension(classDecl)
        }
        return unableToProcess
    }

    private fun generateMergeExtension(classDecl: KSClassDeclaration) {
        val pkg = classDecl.packageName.asString()
        val className = classDecl.simpleName.asString()
        val fileName = "${className}_AutoMerge"
        val props = classDecl.getDeclaredProperties().toList()
        val constructorParams =
            classDecl.primaryConstructor
                ?.parameters
                ?.map { it.name?.asString() }
                ?.toSet() ?: emptySet()
        val dataProps = props.filter { p -> p.simpleName.asString() in constructorParams }

        val content =
            buildString {
                appendLine("package $pkg")
                appendLine()
                appendLine("// Generated by AutoMerge KSP processor. Do not edit.")
                appendLine("@Suppress(\"RedundantNullableReturnType\", \"UNUSED_PARAMETER\")")
                append("fun $className.merge(fallback: $className): $className = this.copy(\n")
                if (dataProps.isNotEmpty()) {
                    dataProps.forEachIndexed { index, prop ->
                        val name = prop.simpleName.asString()
                        val type = prop.type.resolve()
                        val isNullable = type.nullability == Nullability.NULLABLE
                        val rhs = if (isNullable) "this.$name ?: fallback.$name" else "this.$name"
                        val comma = if (index == dataProps.lastIndex) "" else ","
                        append("    $name = $rhs$comma\n")
                    }
                }
                append(")\n")
            }

        codeGenerator
            .createNewFile(
                Dependencies(false, classDecl.containingFile!!),
                pkg,
                fileName,
                "kt",
            ).use { out ->
                OutputStreamWriter(out, Charsets.UTF_8).use { it.write(content) }
            }
    }
}
